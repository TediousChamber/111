#  RCE命令注入—一些绕过

RCE（Remote Code/Command Execution）

制表符:\t   换行符:\n

### 基础绕过

#### 1.空格绕过

产生的原因:在许多编程语言、命令行界面或应用程序中，空格通常被用作分隔命令、参数和函数的重要字符,所以为了防止信息泄露就会将空格禁用，防止命令被执行。

方法：所以为了执行这些命令，就需要一些制表符、换行符等特殊字符替代空格。

##### 1.大括号扩展{}

基本语法：{item1,item2.....},

原理：在 Linux 系统的 Bash 等 shell 中，大括号扩展是一种强大的特性，它允许你生成多个字符串组合，也就是shell会将其扩展为多个由逗号分隔的项，例如：echo {a,b,c}会扩展为echo a b c.

##### 2.$IFS代替空格（$IF$9,${IFS},$IFS这三都可以）

$IFS 即内部字段分隔符（Internal Field Separator），在 shell 里，它是一个环境变量，用来界定单词的边界。默认情况下，`$IFS` 包含空格、制表符和换行符，也就是说，shell 在解析命令行参数时，会把这些字符(就是指空格、换行符、制表符)当作分隔符来区分不同的参数。

原理: `$IFS` 可以实现参数分隔。因为 shell 会把 `$IFS` 代表的字符视为分隔符 `$9`是当前命令的第9个参数，通常为空

基本格式:

```python
cat$IFS/etc/passwd
cat${IFS}flag 
cat$IFS$9flag
```

##### 3.重定向字符<(输入重定向)  <>(读写重定向)

原理:可替代空格起到分隔作用

基本格式:

```python
cat</etc/passwd//cat /etc/passwd

cat<>/etc/passwd

ls;cat flag
```

##### 4.%09绕过（相当于Tab键）

原理:在 URL 编码里，`%09` 代表的是制表符（Tab)在操作语言中被视为空格，所以可与进行绕过

#### 2.绕过黑名单

##### 1.大小写绕过

原理：部分黑名单的过滤规则可能只对特定大小写的关键字进行匹配，攻击者可以通过改变关键字的大小写来绕过过滤

##### 2.拼接绕过

原理：将被黑名单禁止的关键字拆分成多个部分，然后在代码执行时再进行拼接，这样在过滤阶段不会被识别为完整的危险关键字

示例：

```push
a=f b=lag
cat $a$b//cat flag

未初始化的变量，等价于null
ca${u}t f${u}lag//cat flag
```

##### 3.编码绕过

原理：使用各种编码方式对危险关键字进行编码，在执行时再进行解码，绕过基于明文匹配的黑名单过滤。

如：进行base64、url编码等来对关键字进行编码

##### 4.单引号绕过

原理：单引号可以将其中的内容原样输出，不会对特殊字符进行解析。在绕过黑名单时，如果黑名单只对特定上下文中的关键字进行过滤，使用单引号可以避免关键字被误识别

示例：

```bush
w'h'o'am'i
wh''oami   //whoami
```

##### 5.双引号绕过

原理：双引号内的变量会被解析，但特殊字符如单引号、反引号等会被保留。可以利用双引号对变量和命令进行组合，绕过对完整关键字的匹配（也就是在双引号中可以有参数但在单引号中不可以）

示例：

```bush
w"h"o"am"i
wh""oami

$part1 = "f";
$part2 = "alg";
$func = "$part1$part2";//最后都是flag 
```

##### 6.反斜线绕过(\转义危险字符)

原理:它可以让紧跟其后的特殊字符失去原本的特殊含义，变成普通字符。当黑名单针对某些特殊字符进行过滤时，攻击者能够用反斜线对这些字符进行转义，使命令在形式上绕过过滤

示例:

```bash
c\at /et\c/passwd//最后为cat/passwd
```

##### 6.反引号`绕过

原理:如果目标系统的黑名单对某些完整的命令或关键字进行过滤，攻击者可以使用反引号将命令拆分成多个部分，从而绕过过滤

示例:

```bash
`echo c`at /etc/passwd /etc/passwd   //echo cat/etc/passwd
```

##### 7.位置参数的特殊变量`$@`和`$*`

原理:`$@`和`$*`代表全部的位置参数，当没有位置参数时，扩展为空

```
f$@lag  //flag
```



#### 3.目录分隔符( / )过滤绕过

##### 1.直接使用分号;

在这里分号没有替代/只是起到了一个分隔不同的命令，使得多个命令可以在同一行中依次执行，无法像/一样表示层级关系

##### 2.当/被过滤时可以尝试使用编码进行绕过

原理:过滤/可能就是明文被过滤了，然后我们可以使用编码来绕过，通过过滤后服务器会解码会。

通常使用url、base64、十六进制进行编码（原因就是这些时服务器常见数据传输方式、服务器可以识别出如果是一些不常见的就不行了）

示例

```
cat html%2Ffalg
```

##### 3.cat ${HOME:0:1}etc${HOME:0:1}passwd

原理:

**环境变量 `$HOME`**：在 Linux 或类 Unix 系统中，`$HOME` 是一个预定义的环境变量，它存储着当前用户的主目录路径

**变量子串提取**：`${HOME:0:1}` 是 shell 变量的子串提取操作。这种操作的通用格式是 `${variable:start:length}`，意思是从变量 `variable` 的第 `start` 个字符开始，提取长度为 `length` 的子串。这里 `start` 为 0（索引从 0 开始），`length` 为 1，也就是提取 `$HOME` 变量值的第一个字符。由于主目录路径以 `/` 开头，所以 `${HOME:0:1}` 的结果就是 `/`

##### 4.`cat $(echo . | tr '!-0' '"-1')etc$(echo . | tr '!-0' '"-1')passwd `     //cat  /ect/passwd

原理:

**`$(...)` 语法**：`$(...)` 是 shell 中的命令替换语法，它会先执行括号内的命令，然后将命令的输出结果替换到原命令中的相应位置

**`tr` 命令**：`tr` 命令用于对输入字符进行替换操作，其格式为 `tr set1 set2`，会把输入中属于 `set1` 集合的字符替换为 `set2` 集合中对应位置的字符。`tr '!-0' '"-1'` 表示将输入中从 `!` 到 `0` 这个范围内的字符替换为从 `"` 到 `1` 对应位置的字符。在 ASCII 码表中，`.` 位于 `!` 到 `0` 范围内，会被替换为 `/`(tr命令默认基于 ASCII 编码体系来确定字符范围比如：a-z,那么范围就是97-122)

![image-20250331144943441](https://gitee.com/wxy-2005/picture/raw/master/image-20250331144943441.png)

### 绕过管道符`|`

方法:bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)

#### 1. `<<<` 操作符

在 Bash 中，`<<<` 是 Here 字符串操作符，它的作用是把一个字符串作为标准输入传递给命令。例如，`command <<< "input_string"` 会将 `"input_string"` 作为标准输入传递给 `command` 命令。

#### 2. `base64 -d` 命令

`base64 -d` 用于对 Base64 编码的字符串进行解码。`base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==` 这部分会对 `Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==` 进行 Base64 解码。

对 `Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==` 进行解码后得到的字符串是 `cat /etc/passwd | grep 33`。

#### 3. `bash` 命令

最后，`bash<<<` 会把解码后的字符串 `cat /etc/passwd | grep 33` 作为标准输入传递给 `bash` 执行。`cat /etc/passwd | grep 33` 这个命令的功能是读取 `/etc/passwd` 文件的内容，然后使用 `grep` 命令过滤出包含 `33` 的行。

在题目不是很严格的情况下可以直接`|`进行编码即可

| ;    | `whoami;ls`  | 命令的结束符，允许一行多个命令从左到右顺序执行，所有命令都会执行。Windows系统下命令提示符`cmd`无此语法。 |
| ---- | ------------ | ------------------------------------------------------------ |
| &&   | `whoami&&ls` | 逻辑与，只有第一条命令成功执行，才会执行第二条命令。         |
| \|\| | `whoami||ls` | 逻辑或，只有第一条命令失败时，才会执行第二条命令。           |
| \|   |              | 管道符，两个命令都执行，第一条命令的输出作为第二条命令的输入，第一条命令的输出不显示。 |
| &    |              | 后台执行，两个命令同时执行。                                 |
| %0A  |              | PHP环境下使用。                                              |

在|被过滤时也可以使用其他的命令分隔符比如说时这个;就是让命令依次执行来达到目的

# 代码执行与命令执行的区别和联系

- **代码执行**：通常指的是在特定的编程语言环境中，运行一段程序代码。代码可以是高级语言（如 Python、Java、C++ 等）编写的程序，这些代码需要经过编译（对于编译型语言）或者解释（对于解释型语言）才能被计算机理解和执行。代码执行侧重于程序逻辑的实现和算法的运行。
- **命令执行**：一般是指在操作系统的命令行界面中，执行特定的系统命令。这些命令是操作系统提供的，用于完成各种系统管理任务，如文件操作、进程管理、网络配置等。命令执行更侧重于对系统资源的直接操作和管理。

#### 执行环境

- **代码执行**：需要相应的编程语言运行环境。例如，Python 代码需要 Python 解释器，Java 代码需要 Java 虚拟机（JVM）。代码执行通常在应用程序的上下文中进行，由应用程序调用代码来完成特定的功能。
- **命令执行**：在操作系统的命令行界面中进行，不同的操作系统有不同的命令集。例如，在 Windows 系统中使用 CMD 或 PowerShell，在 Linux 和 macOS 系统中使用 Bash 等。命令执行是直接与操作系统交互，对系统进行控制。

一般来说代码执行比较复杂和灵活

#### 二者之间的联系

- 代码可以调用系统命令。在很多编程语言中，都提供了执行系统命令的接口。例如，在 Python 中可以使用`os.system()`或`subprocess`模块来执行系统命令。这样可以在代码中利用系统命令的功能，完成一些代码本身难以实现的任务。
- 命令脚本中也可以调用代码。例如，在 Shell 脚本中可以调用 Python 脚本或其他编程语言的程序，实现自动化的任务处理

也就是说两着之间可以一起使用在平时做题时见到的代码基本上都是既有代码执行也有命令执行



# 一些在PHP的命令执行相关函数

| system()     | 执行外部程序，成功则返回命令输出的最后一行，失败则返回 false。**显示输出** |      |
| ------------ | ------------------------------------------------------------ | ---- |
| exec()       | 执行一个外部程序，**返回**命令执行结果的最后一行内容         |      |
| shell_exec() | 通过 shell 执行命令并将完整的输出以字符串的方式**返回**      |      |
| ``反引号     | 将反引号中的内容作为 shell 命令来执行，并将其输出信息返回，与函数 shell_exec() 相同 |      |
| passthru()   | 执行外部程序并且**显示原始输出**                             |      |
| pcntl_exec   | 在当前进程空间执行指定程序                                   |      |
| popen()      | 执行一个外部命令，并返回一个文件指针，通过这个指针可以读取命令的输出或者向命令输入数据 |      |
| proc_open()  | 执行一个命令，并且打开用来输入/输出的文件指针。              |      |
| pcntl_exec() | 主要用于在当前进程的上下文中执行指定的程序，替换当前进程的映像 成功时就直接进行新的进程与返回值失败是显示false |      |

### 1. `system()`

```php
string|false system ( string $command [, int &$return_var ] )
```

```php
<?php 
system('whoami'); // root
echo system('whoami');
```



- 参数

  ：

  - `$command`：必需，要执行的系统命令。
  - `$return_var`：可选，用来存储命令执行后的返回状态码。

- 返回值

  ：

  - 若命令执行成功，返回命令输出的最后一行。
  - 若执行失败，返回 `false`。

### 2. `exec()`

```php
string|array|false exec ( string $command [, array &$output [, int &$return_var ]] )
```

```php
exec('whoami'); // 无任何输出
var_dump(exec('whoami'))
```

- 参数
  - `$command`：必需，要执行的系统命令。
  - `$output`：可选，若提供此参数，命令执行结果的每一行会作为一个元素存入该数组。
  - `$return_var`：可选，用来存储命令执行后的返回状态码。
- 返回值
  - 成功时返回命令执行结果的最后一行内容。
  - 失败时返回 `false`。

### 3. `shell_exec()`

```php
string|null shell_exec ( string $command )
```

```php
shell_exec('whoami'); // 无任何输出
var_dump(shell_exec('whoami'));
```



- 参数
  - `$command`：必需，要执行的系统命令。
- 返回值
  - 成功时返回命令的完整输出字符串。
  - 若执行失败，返回 `null`。

### 4. 反引号 ``

反引号并非函数，而是一种语法结构，使用方式为：

```php
$output = `your_command_here`;
```

```php
`whoami`; // 无任何输出
var_dump(`whoami`);
```

- 参数
  - 反引号内为要执行的系统命令。
- **返回值**：返回命令的完整输出字符串。

### 5. `passthru()`

```php
void passthru ( string $command [, int &$return_var ] )
```

```php
passthru('whoami'); // root
var_dump(passthru('whoami'));
```

- 参数
  - `$command`：必需，要执行的系统命令。
  - `$return_var`：可选，用来存储命令执行后的返回状态码。
- **返回值**：无返回值，直接将命令的原始输出显示。

### 6. `pcntl_exec()`

```php
bool pcntl_exec ( string $path [, array $args = [] [, array $envs = [] ]] )
```

```php
pcntl_exec("/bin/bash",array($_POST["cmd"]));
pcntl_exec("/bin/bash",array('whoami'));
```

- 参数
  - `$path`：必需，要执行的程序的路径。
  - `$args`：可选，传递给程序的参数数组。
  - `$envs`：可选，传递给程序的环境变量数组。
- 返回值
  - 若执行成功，不会返回，因为当前进程会被新程序替换。
  - 若执行失败，返回 `false`。

### 7. `popen()`

```php
resource|false popen ( string $command , string $mode )
```

- 参数
  - `$command`：必需，要执行的系统命令。
  - `$mode`：必需，指定管道的打开模式，`'r'` 表示只读，`'w'` 表示只写。
- 返回值
  - 成功时返回一个文件指针资源。
  - 失败时返回 `false`。

### 8. `proc_open()`

```php
resource|false proc_open ( string $command , array $descriptorspec , array &$pipes [, string $cwd = null [, array $env = null [, array $other_options = null ]]] )
```

```php
<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // 标准输入，子进程从此管道中读取数据
   1 => array("pipe", "w"),  // 标准输出，子进程向此管道中写入数据
   2 => array("file", "/tmp/error-output.txt", "a") // 标准错误，写入到一个文件
);

echo proc_open('whoami', $descriptorspec, $pipes);
```

- 参数
  - `$command`：必需，要执行的系统命令。
  - `$descriptorspec`：必需，指定进程的输入、输出文件描述符。
  - `$pipes`：必需，用于存储与进程通信的文件指针数组。
  - `$cwd`：可选，进程的工作目录。
  - `$env`：可选，传递给进程的环境变量数组。
  - `$other_options`：可选，其他选项数组。
- 返回值
  - 成功时返回一个进程资源句柄。
  - 失败时返回 `false`。
